---
layout: post
title: 5 Uses for PowerShell on Pentests
meta: "Finding duplicate files can be a tricky task, especially when you have 100's of files spread all over your hard drive."
category:
  - hacking
image: card1-img.png
date: 2020-12-03
tags:
permalink: blog/:title
---
<style>
  .hover-link:hover {
    
  }

  .hover-link {
    font-weight: bold;
    cursor: pointer;
    color: #05cfa3;
  }
</style>

### 1. Checking for duplicate files

Finding duplicate files can be a tricky task, especially when you have 100's of files spread all over your hard drive.  An easy way is to compute the checksum of the files you would like to check and compare them. If we generate checksums for two files, we can declare that the two files aren’t duplicates if the checksums are different and if the checksums are equal, we can claim that the files are identical, considering the fact that getting the same hash for two different files is almost impossible.

>It is possible for collisions to occur with Sha1 and MD5 so it is recommended you either double check with both algorithms (as a collision on both will be unlikely). Of use an algorithm such as Sha512

We can use the following function to get the checksum of any file. 

{% highlight PowerShell %}
Get-FileHash -Algorith sha1 file.txt
{% endhighlight %}

The <code>Get-FileHash</code> algorithm attribute supports the following:

<ul>
<li>SHA1 (160 bits)</li>
<li>SHA256 (256 bits)</li>
<li>SHA384 (384 bits)</li>
<li>SHA512 (512 bits)</li>
<li>MACTripleDES (64 bits)</li>
<li>MD5 (128 bits)</li>
<li>RIPEMD160 (160 bits)</li>
</ul>

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled.png "evilsaint")

### 2. Create ISO files

#### What are ISO files?

ISOs are a type of archive. The easiest way to think of an ISO file is more like a .zip or .cab archive file, only without the compression. An ISO file contains the image of a disk. That means it contains all the files and folders that were on that disk, much like a .zip or .cab file contains a collection of files and folders.

#### What are some of the benefits of ISO files. 

<ul>
<li>Chances of getting viruses in your file are reduced.</li>
<li>Chances of your data being corrupt are reduced after creating an ISO file.</li>
<li>A single ISO file can hold a whole batch of files and tools. </li>
</ul>

Using the <a class="hover-link" target="_blank" href="https://gallery.technet.microsoft.com/scriptcenter/New-ISOFile-function-a8deeffd">code</a> we can find at the following location. We can create an ISO file for storing tools and documents inside and mounting them inside our virtual machines. 

To make the script easier to call we will put in in our profile. Check <a class="hover-link" target="_blank" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-7.1#the-profile-files">this link</a> for more information about PowerShell profiles and the appropriate location.

{% highlight PowerShell %}
New-Item -ItemType Directory $Home\Documents\PowerShell\
New-Item $Home\Documents\PowerShell\Profile.ps1
notepad $Home\Documents\PowerShell\Profile.ps1
{% endhighlight %}

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (1).png "evilsaint")

With the function saved in our profile we can now create and ISO. Lets use the text files we created earlier. 

{% highlight PowerShell %}
gci * | New-ISOFile -Path textfile.iso
{% endhighlight %}

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (2).png "evilsaint")

Lets now mount the disk and boot up our VM

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (3).png "evilsaint")

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (4).png "evilsaint")

Lets hit Ctrl + E to open up explorer and navigate to our mounted ISO

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (5).png "evilsaint")
Out ISO contains the three files from earlier. 

### 3. Using PowerShell to Show Server Response Headers

Using the <code>Invoke-WebRequest</code> or the valid, and shortened <code>iwr</code> we can retrieve interesting information. 

The returned object from <code>Invoke-WebReques</code>t will allow you to see items such as the returned http status code, the links on a page, and forms on the page and of course the returned server headers. 

{% highlight PowerShell %}
$request = Invoke-WebRequest https://evilsaint.co.uk
$request.StatusCode
$request.Headers
$request.RawContent > temp.html
{% endhighlight %}

What these Headers mean I will leave for a future article but check <a class="hover-link" target="_blank" href="https://flaviocopes.com/http-response-headers/">this useful reference</a> in the mean-time.

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (6).png "evilsaint")

### 4. Checking what versions of SSL/TLS the server will support

{% highlight PowerShell %}
“ssl2”, “ssl3”, “tls”, “tls11”, “tls12” | % {

    $TcpClient = New-Object Net.Sockets.TcpClient
    $TcpClient.Connect("evilsaint.com", 443)
    try {
        $SslStream = New-Object Net.Security.SslStream $TcpClient.GetStream()
        $SslStream.ReadTimeout = 15000
        $SslStream.WriteTimeout = 15000
        $SslStream.AuthenticateAsClient("evilsaint.com",$null,$_,$false)
        $KeyExhange = $SslStream.KeyExchangeAlgorithm
        $HashAlgorithm = $SslStream.HashAlgorithm
        $status = $true

    } catch {
        $status = $false
    }

    $TcpClient.Dispose()
    $SslStream.Dispose()

    Write-Host "$_ = $status"
    #Write-Host $KeyExhange
    #Write-Host $HashAlgorithm
}
{% endhighlight %}

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (7).png "evilsaint")

### 5. Alive Hosts And Open Port Detection

While ideally we would always have tools such as Nmap, Masscan and Hping3 to hand; sometimes we just had to live-of-the-land. 

To see if a host is alive we can use <code>Test-NetConnection</code> to send and ICMP ping request. 

{% highlight PowerShell %}
Test-NetConnection evilsaint.com -Port 443
{% endhighlight %}

With a little scripting we can use the Net Sockets TCP Client and loop through a number of ports like so

{% highlight PowerShell %}
1..1024 | % {echo ((new-object Net.Sockets.TcpClient).Connect("evilsaint.com",$)) "Port $ is open!"} 2>$null
{% endhighlight %}

> This can be quite a slow process.

![evilsaint]({{ site.baseurl }}/assets/images/article-images/5-Uses-for-PowerShell-on-Pentests/Untitled (8).png "evilsaint")
Here we can see Port 22 has been left open :-)